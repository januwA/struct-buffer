!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.StructBuffer=e():t.StructBuffer=e()}(this,(function(){return(()=>{"use strict";var t={838:(t,e,n)=>{n.r(e),n.d(e,{BOOL:()=>Y,BYTE:()=>k,CHAR:()=>Z,CStruct:()=>r,DOUBLE:()=>X,DWORD:()=>Q,FLOAT:()=>J,INT:()=>st,LONG:()=>it,LONGLONG:()=>ut,QWORD:()=>q,SHORT:()=>et,StructBuffer:()=>l,UCHAR:()=>tt,UINT:()=>rt,ULONG:()=>ot,ULONGLONG:()=>ct,USHORT:()=>nt,WORD:()=>M,bits:()=>x,char:()=>j,display:()=>ft,double:()=>v,float:()=>G,int:()=>D,int16_t:()=>I,int32_t:()=>H,int64_t:()=>V,int8_t:()=>$,long:()=>R,longlong:()=>B,registerType:()=>N,short:()=>S,sizeof:()=>h,string_t:()=>U,typedef:()=>w,uchar:()=>T,uint:()=>E,uint16_t:()=>P,uint32_t:()=>K,uint64_t:()=>F,uint8_t:()=>W,ulong:()=>z,ulonglong:()=>C,ushort:()=>A});var s={};n.r(s),n.d(s,{BOOL:()=>Y,BYTE:()=>k,CHAR:()=>Z,DOUBLE:()=>X,DWORD:()=>Q,FLOAT:()=>J,INT:()=>st,LONG:()=>it,LONGLONG:()=>ut,QWORD:()=>q,SHORT:()=>et,UCHAR:()=>tt,UINT:()=>rt,ULONG:()=>ot,ULONGLONG:()=>ct,USHORT:()=>nt,WORD:()=>M,char:()=>j,double:()=>v,float:()=>G,int:()=>D,int16_t:()=>I,int32_t:()=>H,int64_t:()=>V,int8_t:()=>$,long:()=>R,longlong:()=>B,short:()=>S,string_t:()=>U,uchar:()=>T,uint:()=>E,uint16_t:()=>P,uint32_t:()=>K,uint64_t:()=>F,uint8_t:()=>W,ulong:()=>z,ulonglong:()=>C,ushort:()=>A});var r={};function i(t,e,n=!1){let s=t;n&&"string"==typeof s&&(s=s.split(""));for(let t=e.length-1;t>=1;t--){const r=t===e.length-1,i=e[t];s=s.reduce(((t,e,n)=>(n%i==0&&t.push([]),t[t.length-1].push(e),t)),[]),n&&r&&(s=s.map((t=>t.join(""))))}return s}function o(t,e,n){for(;e-- >0;)t.setUint8(n++,0)}function u(t,e){return e||new DataView(new ArrayBuffer(t))}function c(t){if(t instanceof DataView)return t;if(Array.isArray(t)&&(t=Uint8Array.from(t)),!ArrayBuffer.isView(t))throw new Error(`Type Error: (${t}) is not an ArrayBuffer!!!`);return new DataView(t.buffer)}function a(t,e){return new Proxy(t,{get:(t,n)=>n in t?t[n]:/\d+/.test(n.toString())?e(t,parseInt(n)):void 0})}function d(t){const e=a(t,((t,n)=>(t.deeps.push(n),e)));return e}function h(t){if(t instanceof l){let e=0;const n=t.maxSize,s=g(t,1);for(;(s+e++)%n;);return(s+e-1)*t.count}return t.isList?t.size*t.count:t.size}function g(t,e){return Object.values(t.struct).reduce(((t,e)=>t+=e instanceof l?e.byteLength:h(e)),0)*(e??t.count)}n.r(r),n.d(r,{defaultTypes:()=>at,from:()=>gt,parse:()=>ht});class f{constructor(t,e,n){return this.structName=e,this.struct=n,this.deeps=[],this.deeps.push(t),d(this)}}class l extends Array{constructor(t,e){return super(),this.structName=t,this.struct=e,this.deeps=[],this.textDecode=new TextDecoder,this.textEncoder=new TextEncoder,this.structKV=Object.entries(e),a(this,((t,e)=>{const n=new f(e,t.structName,t.struct);return n.textDecode=t.textDecode,n.textEncoder=t.textEncoder,n.structKV=t.structKV,Object.setPrototypeOf(n,l.prototype),n}))}get isList(){return!!this.deeps.length}get count(){return this.deeps.reduce(((t,e)=>t*e),1)}get byteLength(){return g(this)}get maxSize(){return Math.max(...Object.values(this.struct).map((t=>t instanceof l?t.maxSize:t.size)))}decode(t,e=!1,n=0){t=c(t);const s=[];let r=this.count;for(;r--;){const r=this.structKV.reduce(((s,[r,i])=>(i instanceof l?(s[r]=i.decode(t,e,n),n+=i.byteLength):(s[r]=i.decode(t,e,n,this.textDecode),n+=h(i)),s)),{});s.push(r)}return this.isList?i(s,this.deeps):s[0]}encode(t,e=!1,n=0,s){const r=u(this.byteLength,s);this.isList&&Array.isArray(t)&&(t=t.flat());for(let s=0;s<this.count;s++){const i=this.isList?t[s]:t;if(void 0!==i)this.structKV.reduce(((t,[s,r])=>{const o=i[s];return r instanceof l?(r.encode(o,e,n,t),n+=r.byteLength):(r.encode(o,e,n,t,this.textEncoder),n+=h(r)),t}),r);else{const t=this.byteLength/this.count;o(r,t,n),n+=t}}return r}}const p="float",O="double",y="string_t",m={1:{1:"getUint8",0:"getInt8"},2:{1:"getUint16",0:"getInt16"},4:{1:"getUint32",0:"getInt32"},8:{1:"getBigUint64",0:"getBigInt64"},f:"getFloat32",d:"getFloat64"};class _{constructor(t,e,n,s,r,i){return this.names=e,this.size=n,this.unsigned=s,this.get=r,this.set=i,this.deeps=[],this.deeps.push(t),d(this)}}class b extends Array{constructor(t,e,n){super(),this.size=e,this.unsigned=n,this.deeps=[],this.names=Array.isArray(t)?t:[t];const[s,r]=function(t){let e=void 0;const n=t.isName(p.toLowerCase())||t.isName(p.toUpperCase()),s=t.isName(O.toLowerCase())||t.isName(O.toUpperCase());if(n&&(e=m.f),s&&(e=m.d),e||(e=m[t.size][+t.unsigned]),!e)throw new Error(`StructBuffer: Unrecognized ${t} type.`);return[e,e.replace(/^(g)/,"s")]}(this);return this.set=r,this.get=s,a(this,((t,e)=>{const n=new _(e,t.names,t.size,t.unsigned,t.get,t.set);return Object.setPrototypeOf(n,b.prototype),n}))}get isList(){return!!this.deeps.length}get count(){return this.deeps.reduce(((t,e)=>t*e),1)}is(t){return t.names.some((t=>this.names.includes(t)))}isName(t){return this.names.includes(t)}decode(t,e=!1,n=0,s){t=c(t);const r=this.isName(y),o=[];let u=this.count;for(;u--;){let i=t[this.get](n,e);if(r){if(0===i)break;s||(s=new TextDecoder),i=s.decode(new Uint8Array([i]))}o.push(i),n+=this.size}return r&&this.deeps.length<2?o.join(""):this.isList?i(o,this.deeps,r):o[0]}encode(t,e=!1,n=0,s,r){const i=u(this.count*this.size,s),o=this.isName(y);this.isList&&Array.isArray(t)&&(t=t.flat(),o&&(t=t.join(""))),o&&(r||(r=new TextEncoder),t=r.encode(t));for(let s=0;s<this.count;s++){const r=(this.isList?t[s]:t)??0;try{i[this.set](n,r,e)}catch(t){i[this.set](n,BigInt(r),e)}n+=this.size}return i}}class L extends b{constructor(t,e){super("<bits>",t,!0),this.bits=e}decode(t,e=!1,n=0){t=c(t);const s={};let r=t[this.get](n,e);return Object.entries(this.bits).forEach((([t,e])=>{s[t]=(r&1<<e)>>e})),s}encode(t,e=!1,n=0,s){const r=u(this.count*this.size,s);let i=0;return Object.entries(t).forEach((([t,e])=>{const n=this.bits[t];void 0!==n&&(i|=e<<n)})),r[this.set](n,i,e),r}}function N(t,e,n=!0){return new b(t,e,n)}function w(t,e){return N(t,e.size,e.unsigned)}function x(t,e){return new L(t.size,e)}const U=N(y,1),j=N(["char","signed char"],1,!1),T=N("unsigned char",1),S=N(["short","short int","signed short","signed short int"],2,!1),A=N(["unsigned short","unsigned short int"],2),D=N(["int","signed","signed int"],4,!1),E=N(["unsigned","unsigned int"],4),R=N(["long","long int","signed long","signed long int"],4,!1),z=N(["unsigned long","unsigned long int"],4),B=N(["long long","long long int","signed long long","signed long long int"],8,!1),C=N(["unsigned long long","unsigned long long int"],8),G=N(p,4),v=N([O,"long double"],8),$=w(["int8_t","__int8"],j),I=w(["int16_t","__int16"],S),H=w(["int32_t","__int32"],D),V=w(["int64_t","__int64"],B),W=w(["uint8_t","unsigned __int8"],T),P=w(["uint16_t","unsigned __int16"],A),K=w(["uint32_t","unsigned __int32"],E),F=w(["uint64_t","unsigned __int64"],C),Y=w("BOOL",D),k=w("BYTE",T),M=w("WORD",A),Q=w("DWORD",z),q=N("QWORD",8),J=w(p.toUpperCase(),G),X=w(O.toUpperCase(),v),Z=w("CHAR",j),tt=w("UCHAR",T),et=w("SHORT",S),nt=w("USHORT",A),st=w("INT",D),rt=w("UINT",E),it=w("LONG",R),ot=w("ULONG",z),ut=w("LONGLONG",B),ct=w("ULONGLONG",C),at=s,dt=/\s*(?<typedef>typedef)?\s*(?<struct>struct)\s*(?<structName>\w+)\s*{(?<props>[^}]*)}(\s*(?<aliasName1>\w+)?\s*,\s*(?<aliasName2>\*\w+)?\s*;\s*)?/gi;function ht(t,e){e=Object.assign(at,e);const n=[...(t=t.replace(/\/\/[^]*?\n|\/\*[^]*\*\//g,"")).matchAll(dt)];if(!n||!n.length)throw new Error("[parseCStruct]: parse error");const s={};for(const t of n){const e=t.groups;if(!e?.struct)throw new Error('[parseCStruct]: Undefined identifier "struct"');const n=e?.aliasName1??e?.structName;if(!n)throw new Error('[parseCStruct]: You need to create a name for "struct"');const r={};e.props&&e.props.trim()&&e.props.trim().split(/\n/).map((t=>{const e=t.trim().replace(/;$/,"").split(/\s+/).map((t=>t.trim()));let n=e.pop(),s=e.join(" "),r=1,i=!1;const o=n.match(/\[(\d+)+\]/);return o&&(n=n.substr(0,o.index),r=parseInt(o[1])||1,i=!0),{type:s,name:n,count:r,isList:i}})).forEach((t=>{r[t.name]=t})),s[n]=r}const r=Object.keys(s).reduce(((t,e)=>Object.assign(t,{[e]:null})),{});for(const[t,n]of Object.entries(s))r[t]=new l(t,Object.entries(n).reduce(((t,[n,i])=>{if(i.type in s)return t[n]=r[i.type],t;if(!e)return t;let o=e[i.type];if(o||(o=Object.values(e).find((t=>{if(t instanceof b&&t.isName(i.type))return t}))),!o)throw new Error(`[parseCStruct]: The (${i.type}) type was not found in styles`);return t[n]=i.isList?o[i.count]:o,t}),{}));return r}function gt(t){let e="";for(let[n,s]of Object.entries(t.struct)){const t=s instanceof b?U.is(s)?j.names[0]:s.names[0]:s.structName;if(s.isList){n=`${n}${s.deeps.map((t=>`[${t}]`)).join("")}`}e+=`\t${t} ${n};\n`}return`\ntypedef struct _${t.structName}\n{\n${e.replace(/\n$/,"")}\n} ${t.structName}, *${t.structName};\n`}function ft(t,e,n){n=Object.assign({hex:!0,littleEndian:!1},n);let s=0;const r=[];for(;;)try{let i=t[e.get](s,n.littleEndian);n.hex&&(i=i.toString(16).toUpperCase().padStart(2*e.size,"0")),r.push({offset:s,value:i}),s+=e.size}catch(t){break}return r}}},e={};function n(s){if(e[s])return e[s].exports;var r=e[s]={exports:{}};return t[s](r,r.exports,n),r.exports}return n.d=(t,e)=>{for(var s in e)n.o(e,s)&&!n.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n(838)})()}));