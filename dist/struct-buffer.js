!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.StructBuffer=e():t.StructBuffer=e()}(this,(function(){return(()=>{"use strict";var t={599:(t,e,s)=>{s.r(e),s.d(e,{BYTE:()=>d,DWORD:()=>p,QWORD:()=>D,StructBuffer:()=>w,WORD:()=>g,char:()=>i,double:()=>a,float:()=>f,int16_t:()=>h,int32_t:()=>_,int64_t:()=>u,int8_t:()=>c,string_t:()=>n,uint16_t:()=>b,uint32_t:()=>l,uint64_t:()=>B,uint8_t:()=>y});class r{}const i=new Proxy(new r,{get(t,e){if(e=e.toString(),/\d+/.test(e))return`char[${e}]`;throw new Error("CHAR type error.")}});class o{}const n=new Proxy(new o,{get(t,e){if(e=e.toString(),/\d+/.test(e))return`string_t[${e}]`;throw new Error("string_t type error.")}}),f="float",a="doubel",c="int8_t",h="int16_t",_="int32_t",u="int64_t",d="byte",g="word",p="dword",D="qword",y="uint8_t",b="uint16_t",l="uint32_t",B="uint64_t";var O;!function(t){t[t.BYTE=1]="BYTE",t[t.WORD=2]="WORD",t[t.DWORD=4]="DWORD",t[t.QWORD=8]="QWORD"}(O||(O={}));class w{constructor(t){this.struct=t,this._textDecode=new TextDecoder,this._textEncoder=new TextEncoder,this._offset=0}get textDecode(){return this._textDecode}set textDecode(t){this._textDecode=t}get textEncoder(){return this._textEncoder}set textEncoder(t){this._textEncoder=t}get byteLength(){let t=0;for(const e in this.struct){const s=this.struct[e];switch(s){case c:t+=O.BYTE;break;case h:t+=O.WORD;break;case _:case u:t+=O.DWORD;break;case d:case y:t+=O.BYTE;break;case g:case b:t+=O.WORD;break;case p:case l:t+=O.DWORD;break;case D:case B:t+=O.QWORD;break;case f:case a:t+=O.DWORD;break;default:if("string"==typeof s){let e=s.match(/(?<type>\w+)\[(?<size>\d+)?\]/i);e&&e.groups?.type&&(e.groups?.size?t+=parseInt(e.groups.size):t+=O.BYTE)}s instanceof r&&(t+=O.BYTE),s instanceof o&&(t+=O.BYTE)}}return t}decode(t,e=!1){const s={};for(const i in this.struct){const n=this.struct[i];let w=0;switch(n){case c:w=O.BYTE,s[i]=t.getInt8(this._offset);break;case h:w=O.WORD,s[i]=t.getInt16(this._offset,e);break;case _:w=O.DWORD,s[i]=t.getInt32(this._offset,e);break;case u:w=O.DWORD,s[i]=t.getBigInt64(this._offset,e);break;case d:case y:w=O.BYTE,s[i]=t.getUint8(this._offset);break;case g:case b:w=O.WORD,s[i]=t.getUint16(this._offset,e);break;case p:case l:w=O.DWORD,s[i]=t.getUint32(this._offset,e);break;case D:case B:w=O.QWORD,s[i]=t.getBigUint64(this._offset,e);break;case f:w=O.DWORD,s[i]=t.getFloat32(this._offset,e);break;case a:w=O.DWORD,s[i]=t.getFloat64(this._offset,e);break;default:if("string"==typeof n){let e=n.match(/(?<type>\w+)\[(?<size>\d+)?\]/i);if(e&&e.groups?.type){if("char"===e.groups?.type.toLowerCase())if(e.groups?.size){const r=parseInt(e.groups.size);s[i]=this._readBytes(t,r)}else w=O.BYTE,s[i]=t.getUint8(this._offset);if("string_t"===e.groups?.type.toLowerCase())if(e.groups?.size){const r=parseInt(e.groups.size);s[i]=this._readBytes(t,r),s[i]=this.textDecode.decode(new Uint8Array(s[i]))}else w=O.BYTE,s[i]=t.getUint8(this._offset),s[i]=this.textDecode.decode(new Uint8Array([s[i]]))}}n instanceof r&&(w=O.BYTE,s[i]=t.getUint8(this._offset)),n instanceof o&&(w=O.BYTE,s[i]=t.getUint8(this._offset),s[i]=this.textDecode.decode(new Uint8Array([s[i]])))}this._offset+=w}return this._offset=0,s}encode(t,e=!1){const s=new DataView(new ArrayBuffer(this.byteLength));for(const i in this.struct){const n=this.struct[i],w=t[i];let E=0;switch(n){case c:E=O.BYTE,s.setInt8(this._offset,w);break;case h:E=O.WORD,s.setInt16(this._offset,w,e);break;case _:E=O.DWORD,s.setInt32(this._offset,w,e);break;case u:E=O.DWORD,s.setBigInt64(this._offset,w,e);break;case d:case y:E=O.BYTE,s.setUint8(this._offset,w);break;case g:case b:E=O.WORD,s.setUint16(this._offset,w,e);break;case p:case l:E=O.DWORD,s.setUint32(this._offset,w,e);break;case D:case B:E=O.QWORD,s.setBigUint64(this._offset,w,e);break;case f:E=O.DWORD,s.setFloat32(this._offset,w,e);break;case a:E=O.DWORD,s.setFloat64(this._offset,w,e);break;default:if("string"==typeof n){let t=n.match(/(?<type>\w+)\[(?<size>\d+)?\]/i);if(t&&t.groups?.type){if("char"===t.groups?.type.toLowerCase())if(t.groups?.size){const e=parseInt(t.groups.size);this._writeBytes(s,w,e)}else E=O.BYTE,Array.isArray(w)?s.setUint8(this._offset,w[0]):s.setUint8(this._offset,w);if("string_t"===t.groups?.type.toLowerCase()&&"string"==typeof w||w instanceof String)if(t.groups?.size){const e=parseInt(t.groups.size);this._writeBytes(s,this.textEncoder.encode(w.toString()),e)}else E=O.BYTE,this._writeBytes(s,this.textEncoder.encode(w.toString()),O.BYTE)}}n instanceof r&&(E=O.BYTE,Array.isArray(w)?s.setUint8(this._offset,w[0]):s.setUint8(this._offset,w)),n instanceof o&&(E=O.BYTE,this._writeBytes(s,this.textEncoder.encode(w[0]),O.BYTE))}this._offset+=E}return this._offset=0,s}_readBytes(t,e){const s=[];for(let r=0;r<e;r++)s.push(t.getUint8(this._offset)),this._offset++;return s}_writeBytes(t,e,s){for(let r=0;r<s;r++){let s=e[r];void 0===s&&(s=0),t.setUint8(this._offset,s),this._offset++}}}}},e={};function s(r){if(e[r])return e[r].exports;var i=e[r]={exports:{}};return t[r](i,i.exports,s),i.exports}return s.d=(t,e)=>{for(var r in e)s.o(e,r)&&!s.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},s.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),s.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},s(599)})()}));