!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.StructBuffer=e():t.StructBuffer=e()}(this,(function(){return(()=>{"use strict";var t={838:(t,e,n)=>{n.r(e),n.d(e,{BOOL:()=>C,BYTE:()=>H,CHAR:()=>k,CStruct:()=>i,DOUBLE:()=>Y,DWORD:()=>F,FLOAT:()=>V,INT:()=>J,LONG:()=>X,LONGLONG:()=>tt,QWORD:()=>P,SHORT:()=>Q,StructBuffer:()=>l,UCHAR:()=>M,UINT:()=>K,ULONG:()=>Z,ULONGLONG:()=>et,USHORT:()=>q,WORD:()=>W,char:()=>_,display:()=>ot,double:()=>R,float:()=>S,int:()=>w,int16_t:()=>E,int32_t:()=>B,int64_t:()=>z,int8_t:()=>A,long:()=>x,longlong:()=>j,registerType:()=>O,short:()=>N,sizeof:()=>d,string_t:()=>m,typedef:()=>y,uchar:()=>L,uint:()=>U,uint16_t:()=>I,uint32_t:()=>v,uint64_t:()=>$,uint8_t:()=>G,ulong:()=>T,ulonglong:()=>D,ushort:()=>b});var s={};n.r(s),n.d(s,{BOOL:()=>C,BYTE:()=>H,CHAR:()=>k,DOUBLE:()=>Y,DWORD:()=>F,FLOAT:()=>V,INT:()=>J,LONG:()=>X,LONGLONG:()=>tt,QWORD:()=>P,SHORT:()=>Q,UCHAR:()=>M,UINT:()=>K,ULONG:()=>Z,ULONGLONG:()=>et,USHORT:()=>q,WORD:()=>W,char:()=>_,double:()=>R,float:()=>S,int:()=>w,int16_t:()=>E,int32_t:()=>B,int64_t:()=>z,int8_t:()=>A,long:()=>x,longlong:()=>j,short:()=>N,string_t:()=>m,uchar:()=>L,uint:()=>U,uint16_t:()=>I,uint32_t:()=>v,uint64_t:()=>$,uint8_t:()=>G,ulong:()=>T,ulonglong:()=>D,ushort:()=>b});var i={};function r(t,e,n=!1){let s=t;n&&"string"==typeof s&&(s=s.split(""));for(let t=e.length-1;t>=1;t--){const i=t===e.length-1,r=e[t];s=s.reduce(((t,e,n)=>(n%r==0&&t.push([]),t[t.length-1].push(e),t)),[]),n&&i&&(s=s.map((t=>t.join(""))))}return s}function o(t,e,n){for(;e-- >0;)t.setUint8(n++,0)}function u(t,e){return e||new DataView(new ArrayBuffer(t))}function c(t,e){return new Proxy(t,{get:(t,n)=>n in t?t[n]:/\d+/.test(n.toString())?e(t,parseInt(n)):void 0})}function a(t){const e=c(t,((t,n)=>(t.deeps.push(n),e)));return e}function d(t){if(t instanceof l){let e=0;const n=t.maxSize,s=g(t,1);for(;(s+e++)%n;);return(s+e-1)*t.count}return t.isList?t.size*t.count:t.size}function g(t,e){return Object.values(t.struct).reduce(((t,e)=>t+=e instanceof l?e.byteLength:d(e)),0)*(e??t.count)}n.r(i),n.d(i,{defaultTypes:()=>nt,from:()=>rt,parse:()=>it});class h{constructor(t,e,n){return this.structName=e,this.struct=n,this.deeps=[],this.deeps.push(t),a(this)}}class l extends Array{constructor(t,e){return super(),this.structName=t,this.struct=e,this.deeps=[],this.textDecode=new TextDecoder,this.textEncoder=new TextEncoder,c(this,((t,e)=>{const n=new h(e,t.structName,t.struct);return n.textDecode=t.textDecode,n.textEncoder=t.textEncoder,Object.setPrototypeOf(n,l.prototype),n}))}get isList(){return!!this.deeps.length}get count(){return this.deeps.reduce(((t,e)=>t*e),1)}get byteLength(){return g(this)}get maxSize(){return Math.max(...Object.values(this.struct).map((t=>t instanceof l?t.maxSize:t.size)))}decode(t,e=!1,n=0){t instanceof DataView||(t=new DataView(t.buffer));const s=[];for(let i=0;i<this.count;i++){const i=Object.entries(this.struct).reduce(((s,[i,r])=>(r instanceof l?(s[i]=r.decode(t,e,n),n+=r.byteLength):(s[i]=r.decode(t,e,n,this.textDecode),n+=d(r)),s)),{});s.push(i)}return this.isList?r(s,this.deeps):s[0]}encode(t,e=!1,n=0,s){const i=u(this.byteLength,s);this.isList&&Array.isArray(t)&&(t=t.flat());for(let s=0;s<this.count;s++){const r=this.isList?t[s]:t;if(void 0!==r)Object.entries(this.struct).reduce(((t,[s,i])=>{const o=r[s];return i instanceof l?(i.encode(o,e,n,t),n+=i.byteLength):(i.encode(o,e,n,t,this.textEncoder),n+=d(i)),t}),i);else{const t=this.byteLength/this.count;o(i,t,n),n+=t}}return i}}class f{constructor(t,e,n,s,i,r){return this.names=e,this.size=n,this.unsigned=s,this.get=i,this.set=r,this.deeps=[],this.deeps.push(t),a(this)}}class p extends Array{constructor(t,e,n){super(),this.size=e,this.unsigned=n,this.deeps=[],this.names=Array.isArray(t)?t:[t];const{set:s,get:i}=function(t){switch(t.size){case 1:return{get:t.unsigned?"getUint8":"getInt8",set:t.unsigned?"setUint8":"setInt8"};case 2:return{get:t.unsigned?"getUint16":"getInt16",set:t.unsigned?"setUint16":"setInt16"};case 4:const e=t.isName("float");return{get:e?"getFloat32":t.unsigned?"getUint32":"getInt32",set:e?"setFloat32":t.unsigned?"setUint32":"setInt32"};case 8:const n=t.isName("double");return{get:n?"getFloat64":t.unsigned?"getBigUint64":"getBigInt64",set:n?"setFloat64":t.unsigned?"setBigUint64":"setBigInt64"};default:throw new Error(`StructBuffer: Unrecognized ${t} type.`)}}(this);return this.set=s,this.get=i,c(this,((t,e)=>{const n=new f(e,t.names,t.size,t.unsigned,t.get,t.set);return Object.setPrototypeOf(n,p.prototype),n}))}get isList(){return!!this.deeps.length}get count(){return this.deeps.reduce(((t,e)=>t*e),1)}is(t){return t.names.some((t=>this.names.includes(t)))}isName(t){return this.names.includes(t)}decode(t,e=!1,n=0,s){t instanceof DataView||(t=new DataView(t.buffer));const i=this.isName("string_t"),o=[];for(let r=0;r<this.count;r++){let r=t[this.get](n,e);if(i){if(0===r)break;s||(s=new TextDecoder),r=s.decode(new Uint8Array([r]))}o.push(r),n+=this.size}return i&&this.deeps.length<2?o.join(""):this.isList?r(o,this.deeps,i):o[0]}encode(t,e=!1,n=0,s,i){const r=u(this.count*this.size,s),o=this.isName("string_t");this.isList&&Array.isArray(t)&&(t=t.flat(),o&&(t=t.join(""))),o&&(i||(i=new TextEncoder),t=i.encode(t));for(let s=0;s<this.count;s++){const i=(this.isList?t[s]:t)??0;try{r[this.set](n,i,e)}catch(t){r[this.set](n,BigInt(i),e)}n+=this.size}return r}}function O(t,e,n=!0){return new p(t,e,n)}function y(t,e){return O(t,e.size,e.unsigned)}const m=O("string_t",1),_=O(["char","signed char"],1,!1),L=O("unsigned char",1),N=O(["short","short int","signed short","signed short int"],2,!1),b=O(["unsigned short","unsigned short int"],2),w=O(["int","signed","signed int"],4,!1),U=O(["unsigned","unsigned int"],4),x=O(["long","long int","signed long","signed long int"],4,!1),T=O(["unsigned long","unsigned long int"],4),j=O(["long long","long long int","signed long long","signed long long int"],8,!1),D=O(["unsigned long long","unsigned long long int"],8),S=O("float",4),R=O(["double","long double"],8),A=y(["int8_t","__int8"],_),E=y(["int16_t","__int16"],N),B=y(["int32_t","__int32"],w),z=y(["int64_t","__int64"],j),G=y(["uint8_t","unsigned __int8"],L),I=y(["uint16_t","unsigned __int16"],b),v=y(["uint32_t","unsigned __int32"],U),$=y(["uint64_t","unsigned __int64"],D),C=y("BOOL",w),H=y("BYTE",L),W=y("WORD",b),F=y("DWORD",T),P=O("QWORD",8),V=y("FLOAT",S),Y=y("DOUBLE",R),k=y("CHAR",_),M=y("UCHAR",L),Q=y("SHORT",N),q=y("USHORT",b),J=y("INT",w),K=y("UINT",U),X=y("LONG",x),Z=y("ULONG",T),tt=y("LONGLONG",j),et=y("ULONGLONG",D),nt=s,st=/\s*(?<typedef>typedef)?\s*(?<struct>struct)\s*(?<structName>\w+)\s*{(?<props>[^}]*)}(\s*(?<aliasName1>\w+)?\s*,\s*(?<aliasName2>\*\w+)?\s*;\s*)?/gi;function it(t,e){e=Object.assign(nt,e);const n=[...(t=t.replace(/\/\/[^]*?\n|\/\*[^]*\*\//g,"")).matchAll(st)];if(!n||!n.length)throw new Error("[parseCStruct]: parse error");const s={};for(const t of n){const e=t.groups;if(!e?.struct)throw new Error('[parseCStruct]: Undefined identifier "struct"');const n=e?.aliasName1??e?.structName;if(!n)throw new Error('[parseCStruct]: You need to create a name for "struct"');const i={};e.props&&e.props.trim()&&e.props.trim().split(/\n/).map((t=>{const e=t.trim().replace(/;$/,"").split(/\s+/).map((t=>t.trim()));let n=e.pop(),s=e.join(" "),i=1,r=!1;const o=n.match(/\[(\d+)+\]/);return o&&(n=n.substr(0,o.index),i=parseInt(o[1])||1,r=!0),{type:s,name:n,count:i,isList:r}})).forEach((t=>{i[t.name]=t})),s[n]=i}const i=Object.keys(s).reduce(((t,e)=>Object.assign(t,{[e]:null})),{});for(const[t,n]of Object.entries(s))i[t]=new l(t,Object.entries(n).reduce(((t,[n,r])=>{if(r.type in s)return t[n]=i[r.type],t;if(!e)return t;let o=e[r.type];if(o||(o=Object.values(e).find((t=>{if(t instanceof p&&t.isName(r.type))return t}))),!o)throw new Error(`[parseCStruct]: The (${r.type}) type was not found in styles`);return t[n]=r.isList?o[r.count]:o,t}),{}));return i}function rt(t){let e="";for(let[n,s]of Object.entries(t.struct)){const t=s instanceof p?m.is(s)?_.names[0]:s.names[0]:s.structName;if(s.isList){n=`${n}${s.deeps.map((t=>`[${t}]`)).join("")}`}e+=`\t${t} ${n};\n`}return`\ntypedef struct _${t.structName}\n{\n${e.replace(/\n$/,"")}\n} ${t.structName}, *${t.structName};\n`}function ot(t,e,n){n=Object.assign({hex:!0,littleEndian:!1},n);let s=0;const i=[];for(;;)try{let r=t[e.get](s,n.littleEndian);n.hex&&(r=r.toString(16).toUpperCase().padStart(2*e.size,"0")),i.push({offset:s,value:r}),s+=e.size}catch(t){break}return i}}},e={};function n(s){if(e[s])return e[s].exports;var i=e[s]={exports:{}};return t[s](i,i.exports,n),i.exports}return n.d=(t,e)=>{for(var s in e)n.o(e,s)&&!n.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n(838)})()}));